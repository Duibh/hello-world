[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/conor/Documents/Projects/hello-world/build.sbt","languageId":"scala","version":1,"text":"\n// The simplest possible sbt build file is just one line:\n\nscalaVersion := \"2.13.8\"\n// That is, to create a valid sbt build, all you've got to do is define the\n// version of Scala you'd like your project to use.\n\n// ============================================================================\n\n// Lines like the above defining `scalaVersion` are called \"settings\". Settings\n// are key/value pairs. In the case of `scalaVersion`, the key is \"scalaVersion\"\n// and the value is \"2.13.8\"\n\n// It's possible to define many kinds of settings, such as:\n\nname := \"hello-world\"\norganization := \"ch.epfl.scala\"\nversion := \"1.0\"\n\n// Note, it's not required for you to define these three settings. These are\n// mostly only necessary if you intend to publish your library's binaries on a\n// place like Sonatype.\n\n\n// Want to use a published library in your project?\n// You can define other libraries as dependencies in your build like this:\n\nlibraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"2.1.1\"\nlibraryDependencies += \"org.scalafx\" %% \"scalafx\" % \"18.0.1-R28\"\nlibraryDependencies += \"org.openjfx\" % \"javafx-controls\" % \"19\"\nlibraryDependencies += \"org.openjfx\" % \"javafx-fxml\" % \"19\"\n\n// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,\n// we're adding the scala-parser-combinators dependency to the set of dependencies\n// that sbt will go and fetch when it starts up.\n// Now, in any Scala file, you can import classes, objects, etc., from\n// scala-parser-combinators with a regular import.\n\n// TIP: To find the \"dependency\" that you need to add to the\n// `libraryDependencies` set, which in the above example looks like this:\n\n// \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"2.1.1\"\n\n// You can use Scaladex, an index of all known published Scala libraries. There,\n// after you find the library you want, you can just copy/paste the dependency\n// information that you need into your build file. For example, on the\n// scala/scala-parser-combinators Scaladex page,\n// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste\n// the sbt dependency from the sbt box on the right-hand side of the screen.\n\n// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's\n// important to note that syntax in *.sbt files doesn't always behave like\n// regular Scala. For example, notice in this build file that it's not required\n// to put our settings into an enclosing object or class. Always remember that\n// sbt is a bit different, semantically, than vanilla Scala.\n\n// ============================================================================\n\n// Most moderately interesting Scala projects don't make use of the very simple\n// build file style (called \"bare style\") used in this build.sbt file. Most\n// intermediate Scala projects make use of so-called \"multi-project\" builds. A\n// multi-project build makes it possible to have different folders which sbt can\n// be configured differently for. That is, you may wish to have different\n// dependencies or different testing frameworks defined for different parts of\n// your codebase. Multi-project builds make this possible.\n\n// Here's a quick glimpse of what a multi-project build looks like for this\n// build, with only one \"subproject\" defined, called `root`:\n\n// lazy val root = (project in file(\".\")).\n//   settings(\n//     inThisBuild(List(\n//       organization := \"ch.epfl.scala\",\n//       scalaVersion := \"2.13.8\"\n//     )),\n//     name := \"hello-world\"\n//   )\n\n// To learn more about multi-project builds, head over to the official sbt\n// documentation at http://www.scala-sbt.org/documentation.html\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\conor\Documents\Projects\hello-world\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/conor/Documents/Projects/hello-world/src/main/scala/Main.scala","languageId":"scala","version":2,"text":"import scalafx.Includes._\r\nimport scalafx.geometry.Insets\r\nimport scalafx.scene.control.{Button, ComboBox, Label}\r\nimport scalafx.scene.layout.{HBox, VBox}\r\nimport scalafx.application.JFXApp\r\nimport scalafx.scene.Scene\r\nimport scalafx.scene.control._\r\nimport scalafx.event.ActionEvent\r\n\r\nobject SpellPointTracker1 extends JFXApp {\r\n  val casterLevelComboBox = new ComboBox(1 to 20) {\r\n    promptText = \"Select Caster Level\"\r\n  }\r\n\r\n  val totalPointsLabel = new Label {\r\n    text = \"Total Spell Points: \"\r\n  }\r\n\r\n  val addSpellButtons = (1 to 9).map { level =>\r\n    val cost = Map(1 -> 2, 2 -> 3, 3 -> 5, 4 -> 6, 5 -> 7, 6 -> 9, 7 -> 10, 8 -> 11, 9 -> 13)(level)\r\n    new Button(s\"Spell Level $level (cost $cost)\") {\r\n      onAction = (event: ActionEvent) => {\r\n        val currentPoints = totalPointsLabel.text().toInt\r\n        val newPoints = currentPoints - cost\r\n        totalPointsLabel.text = s\"Total Spell Points: $newPoints\"\r\n      }\r\n    }\r\n  }\r\n\r\n  val subtractSpellButtons = (1 to 9).map { level =>\r\n    val cost = Map(1 -> 2, 2 -> 3, 3 -> 5, 4 -> 6, 5 -> 7, 6 -> 9, 7 -> 10, 8 -> 11, 9 -> 13)(level)\r\n    new Button(s\"Remove Spell Level $level (refund $cost)\") {\r\n      onAction = (event: ActionEvent) => {\r\n        val currentPoints = totalPointsLabel.text().toInt\r\n        val newPoints = currentPoints + cost\r\n        totalPointsLabel.text = s\"Total Spell Points: $newPoints\"\r\n      }\r\n    }\r\n  }\r\n\r\n  val casterLevelBox = new HBox {\r\n    children = List(casterLevelComboBox, totalPointsLabel)\r\n    spacing = 10\r\n  }\r\n\r\n  val spellLevelBox = new HBox {\r\n    children = addSpellButtons ++ subtractSpellButtons\r\n    spacing = 10\r\n  }\r\n\r\n  stage = new JFXApp.PrimaryStage {\r\n    title.value = \"Spell Point Tracker\"\r\n    scene = new Scene {\r\n      content = List(casterLevelBox, spellLevelBox)\r\n    }\r\n  }\r\n\r\n  // Set the total points label to the default value\r\n  totalPointsLabel.text = s\"Total Spell Points: ${Map(1 -> 4, 2 -> 6, 3 -> 14, 4 -> 17, 5 -> 27, 6 -> 32, 7 -> 38, 8 -> 44, 9 -> 57, 10 -> 64, 11 -> 73, 12 ->  73, 13 -> 83, 14 -> 83, 15 -> 94, 16 -> 94, 17 -> 107, 18 -> 114, 19 -> 123, 20 -> 133)(1)}\"\r\n}"}})[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 15 Mar 2023, 19:36:06[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m

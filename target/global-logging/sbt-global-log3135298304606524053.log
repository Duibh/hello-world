[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/conor/Documents/Projects/spellPoints/hello-world/src/main/scala/Main.scala","languageId":"scala","version":1,"text":"import scalafx.scene.control.{ComboBox, SpinnerValueFactory}\r\nimport scalafx.Includes._\r\nimport scalafx.application.JFXApp\r\nimport scalafx.application.JFXApp.PrimaryStage\r\nimport scalafx.scene.Scene\r\nimport scalafx.scene.control._\r\nimport scalafx.scene.layout._\r\nimport scalafx.geometry.Insets\r\n\r\nobject SpellPointTracker extends JFXApp {\r\n\r\n  // Maps the spell level to the total number of spell points available at that level\r\n  val spellPointTotal: Map[Int, Int] = Map(\r\n    1 -> 4,\r\n    2 -> 6,\r\n    3 -> 14,\r\n    4 -> 17,\r\n    5 -> 27,\r\n    6 -> 32,\r\n    7 -> 38,\r\n    8 -> 44,\r\n    9 -> 57,\r\n    10 -> 64, \r\n    11 -> 73,\r\n    12 -> 73,\r\n    13 -> 83,\r\n    14 -> 83,\r\n    15 -> 94,\r\n    16 -> 94,\r\n    17 -> 107,\r\n    18 -> 114,\r\n    19 -> 123,\r\n    20 -> 133\r\n  )\r\n\r\n   // Maps the spell level to the cost of casting a spell at that level in spell points\r\n  val spellCostPerLevel: Map[Int, Int] = Map(\r\n    1 -> 2,\r\n    2 -> 3,\r\n    3 -> 5,\r\n    4 -> 6,\r\n    5 -> 7,\r\n    6 -> 9,\r\n    7 -> 10,\r\n    8 -> 11,\r\n    9 -> 13\r\n  )\r\n\r\n  // Keeps track of the number of spell points spent at each spell level\r\n  var spellPoints: Map[Int, Int] = Map.empty\r\n\r\n   // Sets the caster level and initializes the spellPoints map with zeros for each spell level\r\n  def setCasterLevel(level: Int, spellCostPerLevel: Map[Int, Int], spellPointTotal: Map[Int, Int]): Unit = {\r\n    spellPoints = spellPointTotal.map { case (k, _) => k -> 0 }\r\n    totalPointsLabel.text = s\"Total spell points: ${spellPointTotal(level)}\"\r\n\r\n    // Sets the maximum value and listener for each spinner\r\n    spellLevelSpinners.foreach(spinner => {\r\n      val level = spinner.userData.asInstanceOf[Int]\r\n      val spellLevel = spellCostPerLevel(level)\r\n\r\n      val valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, spellPointTotal(level), 0)\r\n      valueFactory.setWrapAround(true)\r\n      valueFactory.valueProperty().addListener((_, _, newValue) => {\r\n        val level = spinner.userData.asInstanceOf[Int]\r\n        spellPoints += (level -> newValue)\r\n        totalPointsLabel.text = s\"Total spell points: ${spellPoints.values.sum}\"\r\n        spellLevelSpinners.foreach(otherSpinner => {\r\n          if (otherSpinner != spinner) {\r\n            val otherValueFactory = otherSpinner.getValueFactory.asInstanceOf[SpinnerValueFactory.IntegerSpinnerValueFactory]\r\n            otherValueFactory.setMax((spellPointTotal(level) - spellPoints.values.sum) / spellCostPerLevel(otherSpinner.userData.asInstanceOf[Int]))\r\n          }\r\n        })\r\n      })\r\n      spinner.valueFactory = valueFactory.asInstanceOf[SpinnerValueFactory[Int]]\r\n    })\r\n  }\r\n\r\n  /*def setCasterLevel(level: Int): Unit = {\r\n    println(s\"Setting caster level to $level\")\r\n    spellPoints = spellPointTotal.map { case (k, _) => k -> 0 }\r\n    totalPointsLabel.text = s\"Total spell points: ${spellPointTotal(level)}\"\r\n\r\n    // Set the maximum value for each spinner\r\n    spellLevelSpinners.foreach(spinner => {\r\n      val level = spinner.userData.asInstanceOf[Int]\r\n      val spellLevel = spellCostPerLevel(level)\r\n\r\n      val valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, spellPointTotal(casterLevelComboBox.getValue), 0)\r\n      valueFactory.setWrapAround(true)\r\n      valueFactory.valueProperty().addListener((_, _, newValue) => {\r\n        println(s\"Spinner value changed to $newValue\")\r\n        val level = spinner.userData.asInstanceOf[Int]\r\n        spellPoints += (level -> newValue)\r\n        totalPointsLabel.text = s\"Total spell points: ${spellPoints.values.sum}\"\r\n        spellLevelSpinners.foreach(otherSpinner => {\r\n          if (otherSpinner != spinner) {\r\n            val otherValueFactory = otherSpinner.getValueFactory.asInstanceOf[SpinnerValueFactory.IntegerSpinnerValueFactory]\r\n            otherValueFactory.setMax((spellPointTotal(casterLevelComboBox.getValue) - spellPoints.values.sum) / spellCostPerLevel(otherSpinner.userData.asInstanceOf[Int]))\r\n          }\r\n        })\r\n      })\r\n      spinner.valueFactory = valueFactory.asInstanceOf[SpinnerValueFactory[Int]]\r\n\r\n      /*val valueFactory = spinner.valueFactory.value.asInstanceOf[SpinnerValueFactory.IntegerSpinnerValueFactory]\r\n      valueFactory.setWrapAround(true)\r\n      valueFactory.setValue(0)\r\n      valueFactory.setMin(0)\r\n      valueFactory.setMax(spellPointTotal(level) / spellLevel)\r\n      spinner.setValueFactory(valueFactory)*/\r\n    })\r\n  }*/\r\n\r\n  val spellLevelSpinners: Seq[Spinner[Int]] = spellCostPerLevel.keys.toSeq.sorted.map(level => {\r\n    val spinner = new Spinner[Int](0, spellPointTotal(casterLevelComboBox.getValue) / spellCostPerLevel(level), 0)\r\n    spinner.userData = level.asInstanceOf[AnyRef]\r\n    spinner.value.onChange((_, _, newValue) => {\r\n      val spellLevel = spinner.userData.asInstanceOf[Int]\r\n      spellPoints += (spellLevel -> (newValue * spellCostPerLevel(spellLevel)))\r\n      totalPointsLabel.text = s\"Total spell points: ${spellPoints.values.sum}\"\r\n    })\r\n    spinner\r\n  })\r\n\r\n  val casterLevelComboBox = new ComboBox[Int](1 to 20)\r\n  casterLevelComboBox.selectionModel().selectFirst()\r\n  casterLevelComboBox.value.onChange((_, _, newValue) => {\r\n    setCasterLevel(newValue, spellCostPerLevel, spellPointTotal)\r\n  })\r\n  /*casterLevelComboBox.value.onChange((_, _, newValue) => {\r\n    setCasterLevel(newValue)\r\n  })*/\r\n\r\n\r\n  /*def setCasterLevel(level: Int): Unit = {\r\n    spellPoints = spellPointTotal.map { case (k, _) => k -> 0 }\r\n    totalPointsLabel.text = s\"Total spell points: ${spellPointTotal(level)}\"\r\n    \r\n    // Set the maximum value for each spinner\r\n    spellLevelSpinners.foreach(spinner => {\r\n      val valueFactory = spinner.valueFactory.value\r\n      \r\n      valueFactory.setWrapAround(true)\r\n      valueFactory.setValue(0)\r\n      //valueFactory.maxValueProperty().setValue(Integer.valueOf(spellPointTotal(level)))\r\n\r\n      spinner.setValueFactory(valueFactory)\r\n      //spinner.getValueFactory.setValue(valueFactory) // Update the spinner value if necessary\r\n    })\r\n  }\r\n\r\n  val casterLevelComboBox = new ComboBox[Int](1 to 20)\r\n  casterLevelComboBox.selectionModel().selectFirst()\r\n  casterLevelComboBox.value.onChange((_, _, newValue) => {\r\n    setCasterLevel(newValue)\r\n  })\r\n\r\n  val spellLevelSpinners: Seq[Spinner[Int]] = spellPointTotal.keys.toSeq.sorted.map(level => {\r\n    val spinner = new Spinner[Int](0, spellPointTotal(casterLevelComboBox.getValue), 0)\r\n    spinner.userData = level.asInstanceOf[AnyRef]\r\n    spinner.value.onChange((_, _, newValue) => {\r\n      spellPoints += (level -> newValue)\r\n      totalPointsLabel.text = s\"Total spell points: ${spellPoints.values.sum}\"\r\n    })\r\n    spinner\r\n  })*/\r\n\r\n  val totalPointsLabel = new Label(s\"Total spell points: ${spellPointTotal.values.sum}\")\r\n\r\n  val spellLevelLabels: Seq[Label] = spellCostPerLevel.keys.toSeq.sorted.map(level =>\r\n    new Label(s\"Level $level (${spellCostPerLevel(level)} points)\")\r\n  )\r\n\r\n  val gridPane = new GridPane {\r\n    hgap = 10\r\n    vgap = 10\r\n    padding = Insets(10)\r\n    add(new Label(\"Caster level:\"), 0, 0)\r\n    add(casterLevelComboBox, 1, 0)\r\n    spellLevelLabels.zipWithIndex.foreach { case (label, index) =>\r\n      add(label, 0, index + 1)\r\n      add(spellLevelSpinners(index), 1, index + 1)\r\n    }\r\n    add(totalPointsLabel, 0, spellLevelLabels.size + 1, 2, 1)\r\n  }\r\n\r\n  stage = new PrimaryStage {\r\n    title = \"Spell Point Tracker\"\r\n    scene = new Scene {\r\n      root = new BorderPane {\r\n        center = gridPane\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\conor\Documents\Projects\spellPoints\hello-world\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 1 s, completed 15 Mar 2023, 18:20:58[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
